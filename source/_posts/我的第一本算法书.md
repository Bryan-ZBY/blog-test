---
title: 我的第一本算法书
date: 2021-03-14 11:12:47
tags: 算法
---

# 数据结构
## 链表
在链表中，数据一般都是分散存储于内存中的，无需存储在连续的空间内。
因为数据都是分散存储的，所以如果想要访问数据，只能从第1 个数据开始，顺着指针的指向一一往下访问（这便是顺序访问）。

### 链表的添加和删除
如果想要添加数据，只需要改变添加位置前后的指针指向就可以，访问数据时，我们需要从链表头部开始查找（线性查找），如果目标数据在链表最后的话，需要的时间就是O(n)。
数据的删除也一样，只要改变指针的指向就可以，虽然被删除元素本身还存储在内存中，但是不管从哪里都无法访问这个数据，所以也就没有特意去删除它的必要了。今后需要用到其所在的存储空间时，只要用新数据覆盖掉就可以了。

<!-- more -->

## 数组
数据按顺序存储在内存的连续空间内，由于数据是存储在连续空间内的，所以每个数据的内存地址（在内存上的位置）都可以通过数组下标算出。
由于数据是存储在连续空间内的，所以每个数据的内存地址（在内存上的位置）都可以通过数组下标算出。

### 数组的添加和删除
想要向数组中添加新数据时，必须把目标位置后面的数据一个个移开。所以，如果在数组头部添加数据，就需要O(n) 的时间。删除操作同理。

### 数组和链表比较
在链表和数组中，数据都是线性地排成一列。在链表中访问数据较为复杂，添加和删除数据较为简单；而在数组中访问数据比较简单，添加和删除数据却比较复杂。

## 栈和队列
### 栈 - LIFO
与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。

### 队列 - FIFO
在栈中，数据的添加和删除都在同一端进行，而在队列中则分别是在两端进行的。队列也不能直接访问位于中间的数据，必须通过出队操作将目标数据变成首位后才能访问。

## 哈希表
哈希表存储的是由键（key）和值（value）组成的数据。
在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。

## 堆
堆是一种图的树形结构，在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中。堆中的每个结点最多有两个子结点。
优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出，堆主要被用于实现优先队列。

### 向堆中添加元素
在堆中存储数据时必须遵守这样一条规则：子结点必定大于父结点。因此，最小值被存储在顶端的根结点中。
往堆中添加数据时，为了遵守这条规则，一般会把新数据放在最下面一行靠左的位置。当最下面一行里没有多余空间时，就再往下另起一行，把数据加在这一行的最左端。
此时如果父结点大于子结点，则不符合上文提到的规则，因此需要交换父子结点的位置。重复和父节点比较的操作直到数据都符合规则，不再需要交换为止。

### 从堆中取出元素
从堆中取出数据时，取出的是最上面的数据。这样，堆中就能始终保持取出的数据最小。
由于最上面的数据被取出，因此堆的结构也需要重新调整。
取出最末端元素，将其放入顶端，然后和子节点比较，如果子节点小于父节点，则交换两者的位置，重复此操作知道满足堆的条件。

## 二叉查找树
二叉查找树有两个性质。第一个是每个结点的值均大于其左子树上任意一个结点的值。第二个是每个结点的值均小于其右子树上任意一个结点的值。
根据这两个性质可以得到以下结论。首先，二叉查找树的最小结点要从顶端开始，往其左下的末端寻找。反过来，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找。

### 二叉查找树添加数据
从二叉查找树的顶端结点开始寻找添加数字的位置。将想要添加的1与该结点中的值进行比较，小于它则往左移，大于它则往右移。循环此操作即可添加到合适位置。

### 二叉查找树删除数据
如果需要删除的结点没有子结点，直接删掉该结点即可。
如果需要删除的结点只有一个子结点，那么先删掉目标结点，然后把子结点移到被删除结点的位置上即可。
如果需要删除的结点有两个子结点，那么先删掉目标结点，然后在被删除结点的左子树中寻找最大结点，最后将最大结点移到被删除结点的位置上。
这样一来，就能在满足二叉查找树性质的前提下删除结点了。

### 二叉查找树查找数据
从二叉查找树的顶端结点开始往下查找。和添加数据时一样，把待查找数据和结点中的值进行比较，小于该结点的值则往左移，大于则往右移。

### 什么是 B树
二叉查找树中一个结点最多有两个子结点，但我们可以把子结点数扩展为m（m 为预先设定好的常数）。像这种子结点数可以自由设定，并且形状均衡的树便是B 树。

# 排序算法
## 冒泡排序
冒泡排序就是重复“从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置”这一操作的算法。在这个过程中，数字会像泡泡一样，慢慢从右往左“浮”到序列的顶端，所以这个算法才被称为“冒泡排序”。

## 选择排序
选择排序就是重复“从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换”这一操作的算法。在序列中寻找最小值时使用的是线性查找。

## 插入排序
插入排序是一种从序列左端开始依次对数据进行排序的算法。在排序过程中，左侧的数据陆续归位，而右侧留下的就是还未被排序的数据。
插入排序的思路就是从右侧的未排序区域内取出一个数据，将其与左侧数据从后往前比较，若左边的数字更大，就交换这两个数字。重复该操作，直到左边已归位的数字比取出的数字更小，或者取出的数字已经被移到整个序列的最左边为止。

## 堆排序
首先，在堆中存储所有的数据，并按升序来构建堆。为了排序，需要再从堆中把数据一个个取出来。每次取出新数据则重新构造堆，下次取出的依旧是最小值。
堆排序的运行时间比之前讲到的冒泡排序、选择排序、插入排序的时间都要短，但由于要使用堆这个相对复杂的数据结构，所以实现起来也较为困难。

## 归并排序
归并排序算法会把序列分成长度相同的两个子序列，当无法继续往下分时（也就是每个子序列中只有一个数据时），就对子序列进行归并。
归并指的是把两个排好序的子序列合并成一个有序序列，就是从两个子序列依次取出较小的那个，那么生成的就是排好序的。该操作会一直重复执行，直到所有子序列都归并为一个整体为止。

## 快速排序
快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。
[比基准值小的数] 基准值 [比基准值大的数]
接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序。
快速排序是一种“分治法”。它将原本的问题分成两个子问题（比基准值小的数和比基准值大的数），然后再分别解决这两个问题。

# 数组查找
## 线性查找
线性查找是一种在数组中查找数据的算法，与二分查找不同，即便数据没有按顺序存储，也可以应用线性查找。线性查找的操作很简单，只要在数组中从头开始依次往下查找即可。
线性查找需要从头开始不断地按顺序检查数据，因此在数据量大且目标数据靠后，或者目标数据不存在时，比较的次数就会更多，也更为耗时。

## 二分查找
二分查找也是一种在数组中查找数据的算法。与线性查找不同，它只能查找已经排好序的数据。二分查找通过比较数组中间的数据与目标数据的大小，可以得知目标数据是在数组的左边还是右边。因此，比较一次就可以把查找范围缩小一半。重复执行该操作就可以找到目标数据，或得出目标数据不存在的结论。

## 线性查找和二分查找比较
二分查找的时间复杂度为`O(logn)`，与线性查找的`O(n)` 相比速度上得到了指数倍提高（x=log<sub>2</sub>n，则 n=2<sup>x</sup>）。
但是，二分查找必须建立在数据已经排好序的基础上才能使用，因此添加数据时必须加到合适的位置，这就需要额外耗费维护数组的时间。
而使用线性查找时，数组中的数据可以是无序的，因此添加数据时也无须顾虑位置，直接把它加在末尾即可，不需要耗费时间。
综上，具体使用哪种查找方法，可以根据查找和添加两个操作哪个更为频繁来决定。

# 图的搜索
## 图
由顶点和连接每对顶点的边所构成的图形就是图。
举个例子，若将车站作为顶点，将相邻两站用边连接，就能用图来表现地铁的路线了。

### 加权图
由顶点和边构成的图，而我们还可以给边加上一个值。
这个值叫作边的“权重”或者“权”，加了权的图被称为“加权图”。没有权的边只能表示两个顶点的连接状态，而有权的边就可以表示顶点之间的“连接程度”。
举个例子，如果把两个车站间的票价加在边上，就能表现乘车费了。

### 有向图
当我们想在路线图中表示该路线只能单向行驶时，就可以给边加上箭头，而这样的图就叫作“有向图”。比如网页里的链接也是有方向性的，用有向图来表示就会很方便。与此相对，边上没有箭头的图便是“无向图”。
和无向图一样，有向图的边也可以加上权重。不过使用有向图还可以设置非对称的权重。

## 广度优先搜索
广度优先搜索是一种对图进行搜索的算法。假设我们一开始位于某个顶点（即起点），此时并不知道图的整体结构，而我们的目的是从起点开始顺着边搜索，直到到达指定顶点（即终
点）。在此过程中每走到一个顶点，就会判断一次它是否为终点。广度优先搜索会优先从离起点近的顶点开始搜索。
广度优先搜索的特征为从起点开始，由近及远进行广泛的搜索。因此，目标顶点离起点越近，搜索结束得就越快。

## 深度优先搜索
深度优先搜索和广度优先搜索一样，都是对图进行搜索的算法，目的也都是从起点开始搜索直到到达指定顶点（终点）。深度优先搜索会沿着一条路径不断往下搜索直到不能再继续为止，然后再折返，开始搜索下一条候补路径。
深度优先搜索的特征为沿着一条路径不断往下，一条路走到天黑，进行深度搜索，然后再回头走其他路。

# 安全算法
## 传输数据时的四个问题
### 窃听
A 向B 发送的消息可能会在传输途中被X 偷看。这就是“窃听”。

### 假冒
A 以为向B 发送了消息，然而B 有可能是X 冒充的；反过来， B 以为从A那里收到了消息，然而A 也有可能是X 冒充的。这种问题就叫作“假冒”。

### 篡改
即便B 确实收到了A 发送的消息，但也有可能该消息的内容在途中就被X 更改了。这种行为就叫作“篡改”。

### 事后否认
B 从A 那里收到了消息，但作为消息发送者的A 可能对B 抱有恶意，并在事后声称“这不是我发送的消息”。这种行为便是“事后否认”。

### 解决以上问题的方法
为了应对第一个问题“窃听”，我们会使用 “加密”技术。
为了应对第二个问题“假冒”，我们会使用“消息认证码”或“数字签名”技术。
为了应对第三个问题“篡改”，我们同样会使用“消息认证码”或“数字签名”技术。
其中“数字签名”技术还可以用于预防第四个问题“事后否认”。

## 加密含义
对计算机来说，数据就是一串有意义的数字罗列。密文也是数字罗列，只不过它是计算机无法理解的无规律的数字罗列。
也就是说，加密就是数据经过某种运算后，变成计算机无法理解的数的过程。像这样，将数据变成第三者的计算机无法理解的形式，然后再将其恢复成原本数据的一系列操作就是加密技术。

## 哈希函数
哈希函数输出的无规律数值，这个数值就是“哈希值”。哈希值虽然是数字，但多用十六进制来表示。他并不是无意义的数字字母组合的字符串，而是十六进制数字。

### 哈希函数的特征
- 第一个特征是输出的哈希值数据长度不变。
- 第二个特征是如果输入的数据相同，那么输出的哈希值也必定相同。
- 第三个特征是即使输入的数据相似，但哪怕它们只有一比特的差别，那么输出的哈希值也会有很大的差异。输入相似的数据并不会导致输出的哈希值也相似。
- 第四个特征是即使输入的两个数据完全不同，输出的哈希值也有可能是相同的，虽然出现这种情况的概率比较低。这种情况叫作“哈希冲突”。
- 第五个特征是不可能从哈希值反向推算出原本的数据。输入和输出不可逆这一点和加密有很大不同。
- 最后一个特征是求哈希值的计算相对容易。

## 加密数据的两种方法
加密数据的方法可以分为两种：加密和解密都使用相同密钥的“共享密钥加密”和分别使用不同密钥的“公开密钥加密”。

### 共享密钥加密
共享密钥加密是加密和解密都使用相同密钥的一种加密方式。由于使用的密钥相同，所以这种算法也被称为“对称加密”。

### 共享密钥加密的问题
A 和 B 通信的过程中，密文可能已经被X 窃听了。
这里假设A 和B 无法直接沟通，B 不知道加密时使用的是什么密钥。
A 需要通过某种手段将密钥交给B。和密文一样，A 又在互联网上向B 发送了密钥。B 使用收到的密钥对密文进行解密。
但是，该密钥也有可能会被X 窃听。这样一来，X 也可以使用密钥对密文进行解密了。

### 公开密钥加密
公开密钥加密是加密和解密使用不同密钥的一种加密方法。由于使用的密钥不同，所以这种算法也被称为“非对称加密”。加密用的密钥叫作“公开密钥”，解密用的叫作“私有密钥”。

### 公开密钥加密的优点
在和多人传输数据时，使用公开密钥加密十分方便。不需要为每个发送对象都准备相对应的密钥。需要保密的私有密钥仅由接收方保管，所以安全性也更高。
如果使用共享密钥加密，密钥的需求数量会随着发送人数的增多而急剧增多。

### 公开密钥加密的问题
公开密钥加密存在公开密钥可靠性的问题。
X 想要窃听A 发给B 的数据，于是他也准备了公开密钥PX 和私有密钥SX。
在B 把公开密钥PB 发给A 的时候,X 把公开密钥PB 替换成自己的公开密钥PX,于是公开密钥PX 传到了A 那里。由于公开密钥无法显示自己是由谁生成的，所以A 不会发现自己收到的公开密钥已经被人替换。
A 使用公开密钥PX 对数据加密。当A 把想要给B 的密文发送出去后，X 接收了这个密文。接下来，X 用B 生成的公开密钥PB 加密数据。X把密文发送给B，这个密文由B发出的公开密钥PB加密而成，所以B可以用自己的私有密钥SB来解密。
从收到密文到解密密文都没发生任何问题，因此B也意识不到数据已经被窃听。这种
通过中途替换公开密钥来窃听数据的攻击方法叫作“中间人攻击”（man-in-the-middle attack）。
公开密钥的可靠性会出现问题，就是因为A 无法判断收到的公开密钥是否来自B。
要想解决这个问题，就要用到“数字证书”。
公开密钥加密还有一个问题，那就是加密和解密都比较耗时，所以这种方法不适用
于持续发送零碎数据的情况。要想解决这个问题，就要用到“混合加密”。

### 混合加密
共享密钥加密存在无法安全传输密钥的密钥分配问题，公开密钥加密又存在加密解密速度较慢的问题。结合这两种方法以实现互补的一种加密方法就是混合加密。
在混合加密中，要用处理速度较快的共享密钥加密对数据进行加密。不过，加密时使用的密钥，则需要用没有密钥分配问题的公开密钥加密进行处理。

## 消息认证码
消息认证码可以实现“认证”和“检测篡改”这两个功能。密文的内容在传输过程中可能会被篡改，这会导致解密后的内容发生变化，从而产生误会。消息认证码就是可以预防这种情况发生的机制。
消息认证码就是由密钥和密文生成的值，以下简称为MAC（Message Authentication Code）。
X 没有计算MAC 的密钥，所以即便他可以篡改MAC，也无法让篡改后的密文变得合理。所以，只要B 计算出MAC，发现密文对应的MAC 与自己算出的不同，就能确认通信过程中发生了篡改。

## 数字签名
数字签名不仅可以实现消息认证码的认证和检测篡改功能，还可以预防事后否认问题的发生。由于在消息认证码中使用的是共享密钥加密，所以持有密钥的收信人也有可能是消息的发送者，这样是无法预防事后否认行为的。而数字签名是只有发信人才能生成的，因此使用它就可以确定谁是消息的发送者了。

### 数字签名生成流程
公开密钥加密中，加密使用的是公开密钥P ，解密使用的是私有密钥S 。任何人都可以使用公开密钥对数据进行加密，但只有持有私有密钥的人才能解密数据。然而，数字签名却是恰恰相反的。
首先由A 准备好需要发送的消息、私有密钥和公开密钥。由消息的发送者来准备这两个密钥，这一点与公开密钥加密有所不同。
A 将公开密钥发送给B。A 使用私有密钥加密消息。加密后的消息就是数字签名。A 将消息和签名都发送给了B。B 使用公开密钥对密文（签名）进行解密。B 对解密后的消息进行确认，看它是否和收到的消息一致。流程到此结束。
数字签名使用的是用私有密钥生成签名、用公开密钥验证签名这一机制。

## 数字证书
“公开密钥加密”和“数字签名”无法保证公开密钥确实来自信息的发送者。因此，就算公开密钥被第三者恶意替换，接收方也不会注意到。不过，如果使用数字证书，就能保证公开密钥的正确性。数字证书由可信赖的认证中心提供。
