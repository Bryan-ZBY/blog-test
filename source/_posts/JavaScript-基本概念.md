---
title: JavaScript-基本概念
date: 2021-03-17 12:58:09
tags: JavaScript
---

### 什么是标识符
所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符：
- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
- 其他字符可以是字母、下划线、美元符号或数字。

### 怎么开启严格模式
要在整个脚本中启用严格模式，可以在顶部添加如下代码：
```js
"use strict";
```
这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的JavaScript 引擎切换到严格模式。
在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：
```js
function doSomething(){
  "use strict";
  //函数体
}
```

<!-- more -->

### typeof 操作符的返回值
- "undefined"——如果这个值未定义；
- "boolean"——如果这个值是布尔值；
- "string"——如果这个值是字符串；
- "number"——如果这个值是数值；
- "object"——如果这个值是对象或null；
- "function"——如果这个值是函数。

### null 和 undefined 的区别
对未初始化和未声明的变量执行typeof 操作符都会返回undefined。
从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用typeof 操作符检测null 值时会返回"object"的原因。
只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null 值。这样做不仅可以体现null 作为空对象指针的惯例，而且也有助于进一步区分null 和undefined。

### NaN 的特点是什么
NaN 本身有两个非同寻常的特点。首先，任何涉及NaN 的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN 与任何值都不相等，包括NaN 本身。所以需要 isNaN() 来判断。

### Number()函数的转换规则
如果是Boolean 值，true 和false 将分别被转换为1 和0。
- 如果是数字值，只是简单的传入和返回。
- `如果是null 值，返回0。`
- `如果是undefined，返回NaN。`
- 如果是字符串，遵循下列规则：
- 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成1，"123"会变成123，而"011"会变成11（注意：前导的零被忽略了）；
- 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽略前导零）；
- 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；
- 如果字符串是空的（不包含任何字符），则将其转换为0；
- `如果字符串中包含除上述格式之外的字符，则将其转换为NaN。`
- **一元加操作符的操作与Number()函数相同。**

### parseInt()函数的转换规则
它会忽略字符串前面的空格，直至找到第一个非空格字符。
可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）
```js
var num = parseInt("0xAF", 16); //175
```

### 字符串拼接时发生了什么
```js
var lang = "Java";
lang = lang + "Script";
```
ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，
上方示例实现的过程如下：首先创建一个能容纳10 个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字符串"Script"，因为这两个字符串已经没用了。

### toString()方法特点
数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null 和undefined 值没有这个方法。
在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。

### String()函数的转换规则
- 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；
- 如果值是null，则返回"null"；
- 如果值是undefined，则返回"undefined"。

### 创建Object 的实例
```js
var o = new Object();
-----
这个语法与Java 中创建对象的语法相似；但在ECMAScript 中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号
-----
var o = new Object; // 有效，但不推荐省略圆括号
```

### Object 的每个实例都具有的属性和方法
- constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。
- hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。
- isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in 语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。

### 一元加和减操作符的特点
在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。
在将一元减操作符应用于数值时，该值会变成负数。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数。

### 加法操作符的特点
如果两个操作符都是数值，执行常规的加法计算
如果有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接
如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则
对于undefined 和null，则分别调用String()函数并取得字符串"undefined"和"null"。

### 减法操作符的特点
如果有一个操作数是字符串、布尔值、null 或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN。
如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。
如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。
```js
typeof(+'') //"number"
typeof(''+'') //"string"
typeof(''-'') //"number"
```

### 相等操作符转换规则
如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为0，而 true 转换为1；
如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
`null 和undefined 是相等的。`
`要比较相等性之前，不能将null 和undefined 转换成其他任何值。`
如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN 不等于NaN。
如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

### 为什么很少使用 with 语句
严格模式下使用 with 语句会被视为语法错误。
大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难。

### 看到 switch 的有意思的用法
```js
var num = 25;
switch (true) {
  case num < 0:
    alert("Less than 0.");
    break;
  case num >= 0 && num <= 10:
    alert("Between 0 and 10.");
    break;
  case num > 10 && num <= 20:
    alert("Between 10 and 20.");
    break;
  default:
    alert("More than 20.");
}
```

### 理解下 arguments 对象
arguments 对象是类数组结构。
关于arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步，但他们内存空间是相对独立的。
```js
function doAdd(num1, num2) {
  arguments[1] = 10;
  alert(arguments[0] + num2);
}
doAdd(1,2)  // 11
doAdd(1)    // NaN
```
每次执行这个doAdd()函数都会重写第二个参数，将第二个参数的值修改为10。因为arguments对象中的值会自动反映到对应的命名参数，所以修改arguments[1]，也就修改了num2，结果它们的值都会变成10。
不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。
另外还要记住，如果只传入了一个参数，那么为arguments[1]设置的值不会反应到命名参数中。这是因为arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。

### 
